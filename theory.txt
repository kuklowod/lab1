
*****
Хотя пожалуй сначала необходимо рассказать студентам про учетные записи пользователей и процессы. Мля...
*****

###########################################################################################################
Где-то так должено выглядеть содержание теор части:

1. Пользователь ОС (Пользователь и его учетная запись в ОС, аутентификация, авторизация пользователя, предоставление доступа пользователя к ресурсам ОС)
2. Процессы (Атрибуты процесса, доступ к ресурсам ОС, создание дочерних процессов и т.д.)
3. Объекты файловой системы (Модели контроля доступа, атрибуты объектов, списки контроля доступа, разрешения на взаимодействие с объектом файловой системы)
4. Что такое PAM и Network services switching (пока сам не знаю что сюдать нужно написать)
###########################################################################################################

1. Учетные записи пользователей

	В многопользовательской операционной системе существует задача управления доступом к ресусам. Необходимо предоставить доступ пользователям с соответствующим уровнем привелегий и ограничить не имеющих такового. Для ОС пользователь представляется с помощью учетной записи, которая в свою очередь описывает пользователся, а именно его права на доступ к ресурсам. 
	В ОС Linux информация об учетных записях пользователя содержится в файлах конфигурации /etc/passwd /etc/shadow /etc/group. 
	Файл /etc/passwd содержит нобор строк по одной для каждого пользователя каждая из которых содержит следующую информацию о пользовательской учетной записи:

	- имя (логин)
	- числовой идентификатор пользователя
	- числовой идентификатор основной группы пользователя
	- полное имя пользователя и другие сведенья о пользователе
	- используемая по умолчанию командная оболочка
	- домашний каталог

	Каждый пользователю в ОС Linux присваивается свой уникальный идентификатор UID (user identifier), который в свою очередь присваивается всем процессам и файлам создаваемым пользователем. Аналогичным образом, для установления идентификатора группы владельца используется GID (group identifier), за исключением того что, он может не быть уникальным для пользователя, который в свою очередь может одновременно входит в несколько групп. Домашний каталог является каталогом по умолчанию в который попадает пользователь при успешной аутентификации в системе. Команная оболочка по умолчанию указывает какой именно командный интерпретатор будет предоставлен пользователю для взаимодействия с ОС. Для псевдопользователей, таких как сетевые службы, данный параметр устанавливается в /bin/false для того чтобы предотвратить попытки локально входа в систему и получению командного интерпретатора.
	Каждый пользователь в Linux обязательно входит хотя бы в одну группу пользователей (по умолчанию с таким же именем как и учетная запись пользователя). Информация о группах и их членах груп содержится в файле /etc/group. Каждая строка содержит следующую иинформацию о группе пользователей:
	
	- имя группы
	- числовой идентификатор группы
	- список пользователей входящих в группу
	
	В ранних версиях UNIX подобных систем информация о пароле пользователя хранилась в зашифрованом виде в файле /etc/passwd, однако для выполнения некоторых процессов от имени пользователя необходим доступ к файлу /etc/passwd, т.е. читать данные из даного файла может любой пользователь. Кроме информации о пользователе появляется возможность прочитать значение поля, содержащего информацию о пароле пользователя. Для предупреждения компрометации пароля путем криптоанализа или атак полного перебора информация о паролях пользователей была вынесена в отдельный файл /etc/shadow, доступ к которому имеет только администратор. Формат данных, хранимых файле имеет следующую структуру:

	- имя пользователя
	- пароль пользователя в зашифрованом виде
	- дата создания пароля
	- число дней в течении которых он не может изменить пароль
	- число дней по истечении которых пользователь обязан сменить пароль
	- число дней в течении которых пользователь будет получать информацию о необходимости сменить пароль
	- кол-во дней в течении которых по истечению срока действия пароля пользователю предоставляется доступ в систему
	- дата валидности учетной записи
	- зарезервированные для будущих нужд поля

	Изменение информации о пользователях может производиться путем редактирования данных файлов в текстовом редакторе, однако управление учетными записями пользователей является штатной задачей администрирования и для ее решения создан набор утилит, входящий в состав стандартных дистрибутивов ОС.

 	Passwd. Команда используется для изменения пароля. Обычные пользователи могут сменить только собственные пароли. Суперпользователь может менять пароли любых пользователей. При вызове команды сначала необходимо ввести старый пароль, если он был установлен. Затем предлагается дважды ввести новый пароль. Если указанные операции были сделаны без ошибок, то пароль пользователя будет изменен.
	Useradd. Команда предназначена для добавления нового регистрационного имени пользователя в системе.
	Userdel. Команда предназначена для удаления регистрационных имен пользователей из системы. 
	Usermod. Команда предназначена для изменения регистрационной информации о пользователе в системе.
	Groupadd. Команда используется для создания новой группы в системе. Новую группу может добавить только администратор. Команда groupadd создает новое определение группы в системе путем добавления соответствующей записи в файл /etc/group.
	Groupdel. Команда используется для удаления определения группы из системы.
	Groupmod. Команда предназначена для изменения определения группы в системе. Команда groupmod изменяет определение указанной группы путем изменения соответствующей записи в файле /etc/group. Новое имя группы задается в параметре группа, новый идентификатор группы задается в параметре идентификатор. Опция -o позволяет задать дублирующийся идентификатор группы.


*************************************************
	Для задания на 60 я думаю хватит.
*************************************************

2. Процессы Linux

	ОС Linux предоставляет возможность параллельного (или псевдопараллельного в случае наличия только одного аппаратного процессора) выполнения нескольких пользовательских программ. Каждому такому выполнению соответствует процесс операционной системы. Процесс является абстракцией уровня ОС характеризующуюся контекстом. Каждому процессу соответствует контекст, в котором он выполняется. Этот контекст включает:
	- пользовательский контекст  содержимое аппаратных регистров 
	- регистровый контекст
	- контекст системного уровня (структуры данных ядра) 

	Пользовательский контекст представляет собой содержимое виртуального адресного пространства, сегментов программного кода, данных, стека, разделяемых сегментов и сегментов файлов, отображаемых в виртуальную память.
	Регистровый контекст включает в себя регистр счетчика команд, регистр состояния процессора, регистр указателя стека и регистры общего назначения
	Контекст процесса системного уровня состоит из «статической» и «динамических» частей. Для каждого процесса имеется одна статическая часть контекста системного уровня и переменное число динамических частей.

Статическая часть контекста процесса системного уровня включает следующее:

	Идентификатор процесса (PID). Уникальный номер, идентифицирующий процесс. По сути, это номер строки в таблице процессов — специальной внутренней структуре ядра операционной системы, хранящей информацию о процессах. В любой момент времени ни у каких двух процессов номера не могут совпадать, однако после завершения процесса его номер освобождается и может быть в дальнейшем использован для идентификации любого вновь запущенного процесса.
	Идентификатор родительского процесса (PPID). В Linux процессы выстраиваются в иерархию — новый процесс может быть создан только одним из уже существующих процессов, который выступает для него родительским. Очевидно, что в такой схеме должен присутствовать один процесс с особым статусом: он должен быть порожден ядром операционной системы и будет являться родительским для всех остальных процессов в системе. В Linux такой процесс имеет собственное имя — init. 
	Состояние процесса. Каждый процесс в любой момент времени находится в одном из нескольких определенных состояний: инициализация, исполнение, приостановка, ожидание ввода-вывода, завершение и т. п.
	Идентификаторы пользователя. Идентификатор пользователя и группы, от имени которых исполняется процесс, используются операционной системой для определения границ доступа для процесса.
	Приоритет процесса. Число, используемое при планировании (см. «Планирование процессов») исполнения процесса в операционной системе. Традиционное решение операционной системы UNIX состоит в использовании динамически изменяющихся приоритетов. При образовании каждого процесса ему приписывается некоторый устанавливаемый системой статический приоритет, который в дальнейшем может быть изменен с помощью системного вызова nice. Реальным критерием планирования выступает динамический приоритет, статический приоритет составляет основу начального значения динамического приоритета процесса. Все процессы с динамическим приоритетом не ниже порогового участвуют в конкуренции за процессор. 
	Таблица дескрипторов открытых файлов. Список структур ядра, описывающий все файлы, открытые этим процессом для ввода-вывода. 
Другая информация, связанная с процессом
	Динамическая часть контекста процесса — это один или несколько стеков, которые используются процессом при выполнении в режиме пользователя и в режиме ядра (в процессе прерываний и системных вызовов).
	При создании процесс получает идентификатор пользователя от имени которого он был запущен. Идентификатор группы пользователя устанавливается в соответствии с группой пользователя запустившего процесс. В ОС Linux существует механизм подмены UID, который позволяет пользователю выполнять процессы от имени другого пользователя. Это возможно благодаря использованию идентификаторов EUID (effective user identifier) и EGID (effective group identifier). При принятии решения о предоставлении доступа к ресурсам ОС проверяется EUID и EGID процесса. 
	В ОС Linux существует несколько механизмов позволяющих создавать процессы (выполнять программы) от имени другого пользователя:
	- использование утилиты su
	- использование утилиты sudo
	- установка атрибута setuid исполняемого файла
	
	Su. Команда используется для временной подмены идентификатора пользователя и позволяет пользователю выполнять команды от имени другого пользователя (временно стать другим пользователем с точки зрения ОС). Если не указан параметр пользователь, то используется значение по умолчанию - суперпользователь. Если указанному пользователю назначен пароль, то потребуется его ввести, прежде чем стать другим пользователем. Для того, чтобы стать суперпользователем, нужно ввести команду su без параметров.
	Программа sudo является логическим развитием программы su и позволяет как переходить в сеанс суперпользователя, так и запускать отдельные программы от имени суперпользователя. Главным достоинством команды sudo является возможность гибкого конфигурирования – на какие программы каким пользователям разрешено повышение превилений. Конфигурируют sudo, редактируя файл /etc/sudoers, который (как явствует из его имени) содержит список пользователей, которым разрешено запускать программу sudo. Чтобы редактировать этот файл, необходимо использовать программу visudo, которая следит за правами доступа, устанавливает некоторые “заслоны”, чтобы два различных пользователя не могли одновременно редактировать файл, и даже проверяет, не сделали ли вы ошибок, прежде чем сохранить его. 
	Формат файла /etc/sudoers прост: начинается с четырех опциональных секций, и заканчивается присвоением специальных прав. Файл может включать пустые строки, строки комментариев, которые начинаются со значка #,	список параметров задается с помощью разделителя ",". Опциональные (необязательные) секции следующие:
    * User Alias (Псевдоним пользователя): Присваивает псевдоним одному пользователю (не очень полезно) или группе пользователей. Пользователь может иметь несколько псевдонимов.
    * “Run as” Alias (“Работает как” Псевдоним): Определяет, вместо кого именно пользователь команды sudo будет работать. По умолчанию sudo подразумевает суперпользователя (root), но есть возможность работать вместо кого-либо другого.
    * Host Alias (Псевдоним рабочей станции): Определяет, каким рабочим станциям присваиваются права. Если вы не системный администратор группы из нескольких рабочих станций Linux, то не вам это не нужно.
    * Command Alias (Псевдоним Команды): Определяет псевдоним для той или иной команды. Проще напечатать псевдоним APT, чем полный путь, такой как /usr/sbin/apt-get. 
	Например:
	# Псевдонимы пользователей
	# Первая строка создает псевдоним для трех определенных пользователей.
	# Вторая строка создает псевдоним для одного пользователя
	
	User_Alias	STUDENTS = vasya, petya, masha
	User_Alias	MASHA = masha 

	# Права: кто имеет право запускать что
	# Формат: кто = (от имени какого пользователя) какие программы
	# Примеры
	# Пользователю root разрешается запускать любое приложение от имени любого пользователя
	root            ALL = (ALL) ALL
	# Пользователю vasya разрешается запускать приложение /bin/ls от имени пользователя masha
	vasya           ALL = (masha) /bin/ls

3. Атрибуты объектов файловой системы Linux.

	Каждый файл в системе обладает набором атрибутов принадлежности а) имеет своего хозяина, б) приписан к какой-либо группе пользователей, и в) находится в неких отношениях со всеми прочими. В качестве хозяина файла обычно выступает его создатель. Точнее, хозяин процесса, этот файл создавшего. А еще точнее - пользователь, идентификатор которого был унаследован процессом, создавшим файл, в качестве эффективного UID. То есть если процесс этот по каким-либо причинам получил привилегии root-оператора, то и созданный им файл будет иметь своим хозяином его, а не пользователя, на самом деле процесс запустившего.
	Далее, каждый файл приписывается по умолчанию к основной группе пользователя - хозяина файла, однако такое положение не является непременным. И именно отнесение файла к некоей группе широко используется для разграничения доступа, организации коллективной работы и прочих задач администрирования. Ну и все "прочие" также имеют некие права на файл - и не обязательно более узкие, чем члены его группы (или даже хозяин).
	С атрибутами доступа дело несколько сложнее. Основных из них также три: атрибут чтения, изменения, исполнения, причем смысл их различается для каталогов и всех прочих файлов. Начнем со вторых.
	Право на чтение (read) файла - это возможность считать данный которые он содержит. Атрибут изменения (write) также понятен - он дает право изменить содержимое файла, вплоть до полного удаления (содержимого, но не файла! - никакие атрибуты файла не имеют отношения к возможности его удаления). А атрибут исполнения (execute) означает возможность запустить бинарный файл или скрипт на выполнение.
	Для каталога атрибут чтения позволяет просмотреть его содержимое. Право на изменение каталога - это возможность изменять список содержащихся в нем файлов. Например, удалить или создать новое. При этом необходимо понимать никаких особенных прав на сам файл не требуется, в общем случае можно удалить файл, не имея на него прав не только изменения, но даже чтения, достаточно обладать правом на изменение каталога. При этом, зная точно имя удаляемого файла и полный путь к нему, можно не иметь и права на чтение каталога, к которому файл приписан.
	Наконец, атрибут исполнения для каталога дает право входить в него командой cd. Без этого права какие-либо операции внутри каталога становятся затруднительными. Хотя и возможными: по аналогии с правом чтения легко догадаться, что файл из каталога можно удалить, не входя в него - достаточно знать имя файла и путь к нему.
	Атрибуты доступа связаны с атрибутами принадлежности. То есть для каждой категории обладателей файла или прочих пользователей (они тоже в определенной мере обладатели файла) может быть установлено свое сочетание прав на доступ к нему. Так, пользователь может иметь право на чтение, изменение и исполнение файла или каталога, группа и прочие - иметь права чтения и, если нужно, исполнения: это схема, по которой обычно по умолчанию распределяются атрибуты вновь создаваемого файла.
	Доступ к своим файлам для прочих пользователей может быть запрещен, оставив их только для группы выбраных пользователей. А можно, напротив, запретить право чтения и исполнения для группы, сохранив их для прочих: в этом случае группа доверенных пользователей превращается в группу с ограниченым доступом к файлу. Права доступа проверяются при обращении к нему в строгом порядке: пользователь -> группа -> прочие. И потому, если чтение файла запрещено для членов некоторой группы, к которой файл приписан, их попытки ознакомиться с ним будут отвергнуты, тогда как все прочие пользователи прочтут файл беспрепятственно...
	Кроме атрибутов принадлежности и доступа, которые присваиваются файлу в обязательном порядке, он может иметь и три дополнительных атрибута, называемых иногда атрибутами режима. Это атрибуты:
	- SUID (Set User IDentificator)
	- SGID (Set Group IDentificator)
	- sticky bit
	Первые два имеют смысл только для исполняемых обычных файлов, последний - в основном для каталогов.
Атрибут SUID обеспечивает механизм, благодаря которому файл, которому он присвоен, при запуске на выполнение (именно потому он имеет смысл только для файлов с атрибутом исполнения) порождает процесс, наследующий эффективный UID не юзера, его запустившего, а хозяина файла, правами доступа которого и определяются привилегии процесса. Смысл атрибута SGID аналогичен, только тут процессом наследуется не эффективный UID пользователя, а эффективный GID группы, к которой приписан помеченный файл.
	Атрибут sticky присваивается обычно каталогам, и влечет за собой невозможность удаления из него файла кем бы то ни было, за исключением владельца файла - в обычном случае для этого достаточно иметь права доступа не к файлу, а к каталогу. Установка его целесообразна для каталогов, хранящих всякого рода временные данные (типа /tmp и некоторых подкаталогов ветви /var), права доступа к которым по умолчанию (и по смыслу) допускают их модификацию всеми пользователями. Однако, если право на запись временных файлов пользователь вряд ли сможет использовать во вред, то удаление из таких каталогов чужих файлов вряд ли будет приветствоваться их хозяином. И именно для предотвращения такой ситуации предназначен атрибут sticky.
	Сведения обо всех атрибутах файла можно получить посредством команды ls в "длинном" формате используя опцию -l. В обычном выводе команды ls -l имена пользователя и группы находятся в третьем и четвертом полях, а атрибуты доступа объединены в первом. Он имеет вид

-rwxrwxrwx

что расшифровывается следующим образом. Первая позиция последовательности - тип файла (символ дефиса, -, в примере означает, что мы имеем дело с обычным файлом, для каталога там был бы символ d - от directory, для символьного устройства - символ c, для блочного - символ b). Следующие три символа определяют атрибуты доступа для хозяина файла: r - чтение, w - изменение, x - исполнение. Две последние тройки символов - суть то же самое, но для группы и прочих, соответственно. То есть в данном примере фигурирует исполняемый файл, открытый на чтение, запись и запуск для всех. Если же у кого-либо какое-то право отнято - в соответствующей позиции мы увидим символ дефиса. Так, атрибуты нового текстового файла по описанной выше умолчальной схеме будут выглядеть как

-rw-r--r--

	Если файлу приписан атрибут SUID, в тройке владельца место символа x займет символ s, а при наличии атрибута SGID то же s окажется на месте x в тройке группы. Атрибут sticky маркируется символом t в последней позиции (вместо x для "прочих"). 
	Выше при описании прав доступа использована т.н. символьная нотация, простая и мнемонически понятная (r - от read, o - от other, и т.д.). Однако наряду с ней существует (и активно используется) нотация цифровая, где права доступа обозначаются числами типа 644. Поначалу она кажется загадочной. Однако при ближайшем рассмотрении - ничего подобного. Первая цифра соответствует правам хозяина файла, вторая - правам членов группы, третья - правам разных там прочих, как и при символьной нотации. А сама цифра представляет собой простую арифметическую сумму прав, также выраженных численно - только в двоичной системе счисления, трансформированной в восьмеричную для компактности. А именно: наличию любого права соответствует двоичная единица, отсутствию - двоичный ноль. То есть символьной форме rwxrwxrwx будет соответствовать двоичная 111 111 111, что в восьмеричном пересчете и даст 777 (полный доступ). Образуется она из суммы прав чтения (восьмеричное 4), изменения (восьмеричное 2) и исполнения (восьмеричная 1) в трех позициях. Из чего можно догадаться, что число 000, напротив, означает отсутствие прав на любые действия у кого бы то ни было.
Как правило, атрибутами по умолчанию для созданого файла rw-r--r-- в численной нотации будет выглядеть как 644.
	В численной нотации определяются обычно и права, назначаемые файлу при рождении. Для этого существует команда umask, и ее аргумент в численной форме показывает, какие права из их суммы должны быть отняты от совокупности исходных прав у файла. То есть для получения стандартных (в большинстве систем) прав 644 этот аргумент должен быть равен 022.
	Первым аргументом в правах доступа всегда будет 6 т.к. бит разрешающий выполнение файла всегда устанавливается явно. Изначально правом на исполнение обладают только двоичные файлы, создаваемые компилятором.

4. Подключаемые модули аутентификации (Plugable authentication module PAM)
	Механизм PAM объединняет множество низкоуровневых схем аутентификации в API высокого уровня, позволящий создавать приложения, использующие аутентификацию независимо от применяемой схемы аутентификации. Механизм аутентификации PAM основан на модулях аутентификации. Со стороны приложения PAM предоставляет API для обращения к функциям аутентификации.
Программа (login, su, ftp, httpd и т.п.). Самой важной возможностью PAM является гибкость настройки аутентификации. Системный администратор может указать любой способ аутентификации для любой программы. Правда, при этом необходимо, чтобы программа поддерживала аутентификацию через PAM.
	Модуль PAM представляет собой динамически присоединяемый модуль (файл с расширением .so), т.е. фактически - разделяемую библиотеку.
	С точки зрения PAM, аутентификация состоит из нескольких независимых задач:

    - управление учетными записями;
    - управление аутентификацией;
    - управление паролями;
    - управление сессиями.

	Для идентификации этих задач в конфигурационном файле используются аббревиатуры account, auth, password, session.
Решение одной или нескольких из этих задач требуется при доступе пользователя к ресурсу.
Какие цели у модуля, решающего ту или иную задачу?
	account - описывает службу проверки учетной записи, которая отвечает на вопросы: "есть ли такая запись и не истек ли срок действия пароля? имеет ли пользователь право доступа к запрошенному ресурсу?"
authentication - описывает службу проверки идентичности пользователя. Эта служба реализована посредством диалога между пользователем и программой аутентификации: "как тебя зовут и какой у тебя пароль?" Здесь пользователь обязан сообщить соответствующие друг другу имя и пароль (или иное подтверждение того, что пользователь именно тот, за кого он себя выдает).
Некоторые методы аутентификации (например, смарт-карты) не предполагают диалога, идентификацию выполняет специальная аппаратура, которая общается с написанным специально для нее модулем PAM. В этом проявляется гибкость PAM: старый добрый login может не задавать вопросов "login:", "password:".
Не меняя программ, требующих аутентификацию, PAM позволяет аутентифицировать пользователя любым способом, который изберет системный администратор. Может быть сейчас он еще и не знает, что он выберет через год, а кто-то уже пишет PAM-модуль для своей аппаратуры опознавания сотрудника по запаху.
	password - описывает службу изменения пароля; такая служба должна быть тесно связана со службой проверки учетной записи. Например, по истечении срока действия пароля система требует у пользователя новый пароль.
	session - описывает работы, которые должны быть выполнены до того, как ресурс будет предоставлен, или после того, как он будет освобожден (например, после разрыва соединения между программой-клиентом и вызванной им службой-сервером). Это может быть протоколирование начала и конца соединения, монтирование домашнего каталога пользователя и т.п.
	Настройки конфигурации PAM содержатся в файле /etc/pam.conf или в каталоге /etc/pam.d/. В случае использования файла /etc/pam.conf правила располагаются в виде строк, каждая из которых задает правило. В случае использования каталога /etc/pam.d/ для каждой службы, использующей PAM, в каталоге создается соответствующий файл, содержащий правила и инструкции о том, какая информация об аутентификации или учетной записи должна быть предоставлена для этой службы, данные в файле /etc/pam/conf игнорируются.
	Поля файла конфигурации PAM содержат следующую информацию:
    - Service_name указывает название службы или приложения. По умолчанию – OTHER.
    - Module_type указывает тип модуля (auth|account|session|passwd) для соответствующей службы, указанной в поле Service_name.
    - Control_flag указывает дополнительное свойство для модуля. Оно может принимать следующие значения: requisite (необходимый), required (требуемый), sufficient (достаточный. Eсли модуль помечен как достаточный и перед ним ни один из необходимых или достаточных модулей не возвратил отрицательного ответа, то все оставшиеся модули в стеке игнорируются, и возвращается положительный ответ. если в стеке нет требуемых модулей и ни один из достаточных модулей не возвратил положительного ответа, то хотя бы один из дополнительных модулей приложения или службы должен вернуть положительный ответ.) и optional (необязательный).
    - Module_path указывает путь к объекту библиотеки, использующемуся в модуле. По умолчанию он имеет значение /lib/security.
    - Module_options/module_args (дополнительные поля) указывает параметры или аргументы, которые могут быть переданы модулям службы.

Пример конфигурационного файла для демона at:

#
auth    required        pam_env.so
@include common-auth
@include common-account
@include common-session
session    required   pam_limits.so
#

	Модули вызываются в том порядке, в котором они указаны в файле конфигурации, в зависимости от значения поля Control_flag (Управляющий флаг) для каждого модуля, причем, все службы, использующие PAM, должны быть явно настроены для разрешения аутентификации, иначе попытки будут отвергнуты.
